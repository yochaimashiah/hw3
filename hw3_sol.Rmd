
---
title: "Network Analysis"
author: "yochai"
output: 
  md_document:
    variant: markdown_github
---

Setting a working directory:
```{r}
folder = 'C:\\Users\\DELL\\Desktop\\study\\year4\\DataS\\HW3\\hw3'
setwd(folder)

#Or for all chuncks in this Rmarkdown:
knitr::opts_knit$set(root.dir = folder)
```

#Question 1.a:
Load Grey's Anatomy network of romances (ga_edgelist.csv).
```{r, message=FALSE, warning=FALSE}
#install.packages('igraph')
library(igraph)
ga.data <- read.csv('ga_edgelist.csv', header = T)
g <- graph.data.frame(ga.data,directed = F)
```

Calculate degree for the various nodes, set vertix size according to its degree and plot the graph.
```{r}
set.seed(123)
degr.score <- degree(g)
V(g)$size <- degr.score * 2 # multiply by 2 for scale 
plot(g) 
```


Calculate betweenness score-
The vertex betweenness are (roughly) defined by the number of geodesics (shortest paths) going through a vertex
###Highest- sloan  115.36667
```{r}
betweenness_score = betweenness(g)
betweenness_score = sort(betweenness_score, decreasing = TRUE)
betweenness_score
```


Calculate closeness-
Closeness is based on the length of the average shortest path between a node and all other nodes in the network.
Closeness centrality measures how many steps is required to access every other vertex from a given vertex.
###Highest- torres 0.003194888
```{r}
closeness_score = closeness(g, mode="all")
closeness_score = sort(closeness_score, decreasing = TRUE)
closeness_score
```


Eigenvector centrality score-
How central you are depends on how central your neighbors are.
Centrality is proportional to the sum of neighbors’ centralities.
###Highest- torres karev 1.0
```{r}
Eigenvector_score = eigen_centrality(g, directed = TRUE, scale = TRUE, weights = NULL,
  options = arpack_defaults)
Eigenvector_score
```


# Question 2:
##Analyze Facebook

```{r, message=FALSE, warning=FALSE}
#install.packages("devtools")
library(devtools)

#install_github("Rfacebook", "pablobarbera", subdir="Rfacebook")
require (Rfacebook)

#install.packages(tm)
library(tm)
```


```{r, message=FALSE, warning=FALSE}
load("fb_oauth")
tokenn='EAACEdEose0cBADD9bkpCWhZC0isw3hL87YS5tgFmPChKX9ZCV3dZBZA99FHAYSmXXkkZB0kTodY0lH00XZCarinOpgxxXCPBAIC8omgY52MI8fEl0fEfJ7WmWkyADgZCKOdkcY2kNihIbvC4ZAJqiuxvwdieibw6UY7fwz2LR3ZAYSNgenDugS2Hm'
```

1. Get 10 posts from page "cnnbrknews" from facebook
2. Extract the messages
3. Create Term-Document Matrix from the posts- without Punctuation and stopwords.
   *Document=message
4. Build a term-Document graph that displays connections between terms that appear together in common posts
   *vertex= term, edge= connections between terms that appear together in common posts
5. Beautify our graph by setting the degree attribute (normlize the label size by dividing with maximal size).
6. Display plot of graph with kamada kawai algorithm

```{r}

#get the data- 10 posts from page "cnnbrknews""
fb_page <- getPage(page="cnnbrknews", token=fb_oauth, n=10)
corpus <- Corpus(VectorSource(fb_page$message))

#create term-Document Matrix without Punctuation and stopwords
termDocMatrix=TermDocumentMatrix(corpus,control = list(removePunctuation = TRUE,
                                         stopwords = TRUE))

termDocMatrix
```

```{r}
#create term-Document graph 
require(igraph)
net <- graph.incidence(termDocMatrix)

proj_net <- bipartite.projection(net)
net <- proj_net$proj1
```

```{r}
#Beautify our graph
degr.score <- degree(net)
V(net)$size <- degr.score * 0.5 # multiply by 2 for scale 
V(net)$label.cex<-  2.2 * V(net)$size / max(V(net)$size) + .2
```

```{r}
#print the graph 
l <- layout_with_kk(net)
plot(net, layout=l)
tkplot(net, layout=l)
summary(net)
```

calc betweenness_score
```{r}
betweenness_score = betweenness(net)
betweenness_score = sort(betweenness_score, decreasing = TRUE)
betweenness_score
```

calc closeness_score
```{r}
closeness_score = closeness(net, mode="all")
closeness_score = sort(closeness_score, decreasing = TRUE)
closeness_score
```

calc Eigenvector_score
```{r}
Eigenvector_score = eigen_centrality(net, scale = TRUE, weights = NULL,
  options = arpack_defaults)
Eigenvector_score
```

